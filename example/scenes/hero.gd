extends CombatActor

@export var available_moves : Array[CombatMove]
@export var cam : Camera3D
@export var anim : AnimationPlayer
@export_group("Equipment")
@export var available_weapons : Array[EquipmentItem]
@export var available_armors : Array[EquipmentItem]
@export var available_amulets : Array[EquipmentItem]

@export_group("Parameters")
@export var move_maxspeed := 8.0
@export var move_accel := 32.0
@export var move_brake := 64.0

var available_all_equipment : Array[Array]
var current_equipment : Array[EquipmentItem] = [null, null, null]
var last_input_direction := Vector3.FORWARD
var last_shoot_direction := Vector3.FORWARD


func _ready():
	stats.stat_changed.connect(_on_stat_changed)
	var starting_stats := stats.get_stats()
	for k in starting_stats:
		_on_stat_changed(k, starting_stats[k], 0.0)

	available_all_equipment = [
		available_weapons,
		available_armors,
		available_amulets,
	]
	for i in 3:
		var option_b := $"HUD/Control/Stats/EquipChooser".get_child(i * 2 + 1)
		option_b.clear()
		for x in available_all_equipment[i]:
			option_b.add_item(x.resource_name)

		option_b.item_selected.connect(switch_equip.bind(i))
		switch_equip(0, i)


func _physics_process(delta):
	var input_vec := Input.get_vector(&"ui_left", &"ui_right", &"ui_up", &"ui_down")
	var velocity_h := Vector2(velocity.x, velocity.z)
	var speed_delta := move_brake
	if input_vec != Vector2.ZERO:
		# Changes speed at `move_brake` if pushing against velocity vec, `move_accel` if forwards or sideways
		speed_delta = move_accel - 0.5 * move_brake * (input_vec.dot(velocity_h.normalized()) - 1.0)
		last_input_direction = Vector3(input_vec.x, 0, input_vec.y).normalized()
		if anim.current_animation != &"run":
			anim.play(&"run")

	else:
		anim.play(&"idle")

	velocity_h = velocity_h.move_toward(input_vec * move_maxspeed, delta * speed_delta)
	velocity = Vector3(velocity_h.x, 0, velocity_h.y)
	if input_vec.x != 0:
		$"Visual/Flip/Sprite3D".flip_h = input_vec.x > 0

	move_and_slide()


func use_move(index : int):
	var move := available_moves[index]

	# First, apply the move's reactions and triggers.
	# This example only covers personal buffs.
	reactions.add_reactions(move.user_reactions)
	if move.user_stats != null:
		move.user_stats.apply(stats)

	var mouse_pos := get_viewport().get_mouse_position()
	var mouse_hit : Vector3 = get_world_3d().direct_space_state.intersect_ray(
		PhysicsRayQueryParameters3D.create(
			cam.project_ray_origin(mouse_pos),
			cam.project_ray_normal(mouse_pos) * 1000.0,
		)).get(&"position", position + last_shoot_direction)
	var shoot_direction := position.direction_to(Vector3(mouse_hit.x, position.y, mouse_hit.z))
	last_shoot_direction = shoot_direction
	for x in move.scenes:
		# Spawn the projectile.
		var scene_instance := x.instantiate()
		scene_instance.position = position
		add_sibling(scene_instance)
		if scene_instance.has_method(&"launch"):
			scene_instance.scale *= stats.get_stat(&"projectile_size", 1.0)
			scene_instance.launch(
				stats.get_stat(&"weapon_damage"),
				move,
				shoot_direction * stats.get_stat(&"projectile_speed", 8.0),
				self
			)

		# Here's the trigger call! The ability_used method was generated by the database resource.
		# The database is accessible from the Inspector in any TriggerReaction resource.
		var result := reactions.ability_used(move, null, [scene_instance])
		for y in result.spawned_nodes:
			y.target_hit.connect(_on_target_hit)

	# Don't forget to remove reactions and stats without a timer! They'd stay permanently.
	if move.user_stats != null && move.user_stats.expires_in == 0:
		stats.clear(move.user_stats.at_path)

	for x in move.user_reactions:
		if x.expires_in == 0:
			reactions.remove_reaction(x.reaction_id, x.trigger_id)


func switch_equip(item_index : int, slot_index : int):
	if current_equipment[slot_index] != null:
		for x in current_equipment[slot_index].reactions:
			reactions.remove_reaction(x.reaction_id, x.trigger_id)

		if current_equipment[slot_index].stats != null:
			stats.clear(current_equipment[slot_index].stats.at_path)

	# After removing old reactions and stats, add ones from the new item.
	var new_equip : EquipmentItem = available_all_equipment[slot_index][item_index]
	current_equipment[slot_index] = new_equip
	reactions.add_reactions(new_equip.reactions)
	stats.set_from_modification(new_equip.stats)


func _unhandled_input(event):
	if event is InputEventMouseButton:
		if event.pressed:
			match event.button_index:
				MOUSE_BUTTON_LEFT: use_move(0)
				MOUSE_BUTTON_RIGHT: use_move(1)

	if event is InputEventKey:
		if event.pressed:
			if event.keycode >= KEY_1 && event.keycode < KEY_1 + available_moves.size() - 2:
				use_move(event.keycode - KEY_1 + 2)


func _on_target_hit(target_hurtbox : Area3D, damage_result):
	# trigger_input_values references INITIAL damage, before reactions such as damage reduction.
	# This is enabled in the Trigger Database resource.
	var _result := reactions.hit_landed(
		target_hurtbox.get_parent(),
		damage_result.ability,
		damage_result.damage,
		damage_result.trigger_input_values.damage,
	)
	# Do whatever with result


func _on_stat_changed(stat : StringName, new_value : float, old_value : float):
	match stat:
		&"movement_speed":
			move_maxspeed = new_value

	_update_stat_hud(stat, new_value, old_value)


func _update_stat_hud(stat : StringName, new_value : float, _old_value : float):
	match stat:
		&"max_hp":
			# WARNING: instant update of current HP might set it value to 0.
			# You might want to only limit it before a damage instance, or otherwise buffer the excess.
			$"HUD/Control/ResourceBars/Life".max_value = new_value
			$"HUD/Control/ResourceBars/Life".value = 12
			$"HUD/Control/ResourceBars/GridContainer/MaxHP".text = "/ " + str(new_value)
		&"max_mp":
			# WARNING: instant update of current MP might set it value to 0.
			# You might want to only limit it before an ability use, or otherwise buffer the excess.
			$"HUD/Control/ResourceBars/Magic".max_value = new_value
			$"HUD/Control/ResourceBars/Magic".value = 12
			$"HUD/Control/ResourceBars/GridContainer/MaxMP".text = "/ " + str(new_value)
		&"primary_bravery", &"primary_agility", &"primary_wit":
			$"HUD/Control/Stats/Box/Stats".text = "ðŸŸ %s ðŸŸ¢%s ðŸŸ£%s " % [
				stats.get_stat(&"primary_bravery"),
				stats.get_stat(&"primary_agility"),
				stats.get_stat(&"primary_wit"),
			]
		&"weapon_damage", &"projectile_speed", &"projectile_size", &"movement_speed":
			$"HUD/Control/Stats/Stats2".text = "âš”%.1f ðŸš€%.1f ðŸŽ±%.1f ðŸ‘Ÿ%.1f" % [
				stats.get_stat(&"weapon_damage"),
				stats.get_stat(&"projectile_speed"),
				stats.get_stat(&"projectile_size"),
				stats.get_stat(&"movement_speed"),
			]
		&"defense", &"dodge_chance":
			$"HUD/Control/Stats/Stats3".text = "ðŸ›¡%.1f ðŸŒª%.1f%s " % [
				stats.get_stat(&"defense"),
				stats.get_stat(&"dodge_chance"), "%",
			]
